// Package v1alpha1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package v1alpha1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Error An error response.
type Error struct {
	Code  int    `json:"code"`
	Error string `json:"error"`
}

// Model A model represents a machine learning service fullfilling requests.
type Model struct {
	Created time.Time `json:"created"`
	ID      int       `json:"id"`

	// Name Name of the model.
	Name string `json:"name"`

	// Organization ID of the model's organization.
	Organization int       `json:"organization"`
	Updated      time.Time `json:"updated"`
}

// Organization An organization is a namespace holding models and their schemas.
type Organization struct {
	Created time.Time `json:"created"`
	ID      int       `json:"id"`

	// Name Name of the organization.
	Name    string    `json:"name"`
	Updated time.Time `json:"updated"`
}

// Result A result represents the output produce by a particular version of a machine learning service fullfilling requests.
type Result struct {
	Created time.Time `json:"created"`
	ID      int       `json:"id"`

	// Input The input given to the model to produce this result.
	Input string `json:"input"`

	// Model ID of the model.
	Model int `json:"model"`

	// Organization ID of the model's organization.
	Organization int `json:"organization"`

	// Output The output that produced by the model for the given input.
	Output string `json:"output"`

	// Time The timestamp of when the result was produced. Defaults to the time that the model-tracking server receives the request.
	Time time.Time `json:"time"`

	// TrueOutput The correct output that should be produced for the given input.
	TrueOutput string    `json:"trueOutput"`
	Updated    time.Time `json:"updated"`

	// Version ID of the version.
	Version int `json:"version"`
}

// Schema A schema represents the expected structure of the inputs and outputs of a machine learning service.
type Schema struct {
	Created time.Time `json:"created"`
	ID      int       `json:"id"`

	// Input The JSON Schema description of the model's inputs.
	Input json.RawMessage `json:"input"`

	// Name Name of the model.
	Name string `json:"name"`

	// Organization ID of the model's organization.
	Organization int `json:"organization"`

	// Output The JSON Schema description of the model's output.
	Output  json.RawMessage `json:"output"`
	Updated time.Time       `json:"updated"`
}

// Version A version represents a version of a machine learning service fullfilling requests.
type Version struct {
	Created time.Time `json:"created"`
	ID      int       `json:"id"`

	// Model ID of the model.
	Model int `json:"model"`

	// Name Name of the model.
	Name string `json:"name"`

	// Organization ID of the model's organization.
	Organization int `json:"organization"`

	// Schema ID of the schema of the model's inputs and outputs.
	Schema  int       `json:"schema"`
	Updated time.Time `json:"updated"`
}

// ParameterModel defines model for Model.
type ParameterModel = string

// ParameterOrganization defines model for Organization.
type ParameterOrganization = string

// ParameterResult defines model for Result.
type ParameterResult = int

// ParameterSchema defines model for Schema.
type ParameterSchema = string

// ParameterVersion defines model for Version.
type ParameterVersion = string

// ErrorResponse An error response.
type ErrorResponse = Error

// OrganizationsCreateJSONBody defines parameters for OrganizationsCreate.
type OrganizationsCreateJSONBody struct {
	// Name The name of the organization.
	Name string `json:"name"`
}

// ModelsCreateForOrganizationJSONBody defines parameters for ModelsCreateForOrganization.
type ModelsCreateForOrganizationJSONBody struct {
	// Name The name of the model.
	Name string `json:"name"`
}

// VersionsCreateForModelJSONBody defines parameters for VersionsCreateForModel.
type VersionsCreateForModelJSONBody struct {
	// Name The name of the version.
	Name string `json:"name"`

	// Schema The ID of the schema used by this version of the model.
	Schema int `json:"schema"`
}

// ResultsCreateForVersionJSONBody defines parameters for ResultsCreateForVersion.
type ResultsCreateForVersionJSONBody struct {
	// Input The input given to the model to produce this result.
	Input string `json:"input"`

	// Output The output produced by the model for the given input.
	Output string `json:"output"`

	// Time The timestamp of when the result was produced. Defaults to the time that the model-tracking server receives the request.
	Time *time.Time `json:"time,omitempty"`

	// TrueOutput The correct output that should be produced for the given input.
	TrueOutput string `json:"trueOutput"`
}

// SchemasCreateForOrganizationJSONBody defines parameters for SchemasCreateForOrganization.
type SchemasCreateForOrganizationJSONBody struct {
	// Input The JSON Schema description of the model's inputs.
	Input json.RawMessage `json:"input"`

	// Name The name of the schema.
	Name string `json:"name"`

	// Output The JSON Schema description of the model's outputs.
	Output json.RawMessage `json:"output"`
}

// OrganizationsCreateJSONRequestBody defines body for OrganizationsCreate for application/json ContentType.
type OrganizationsCreateJSONRequestBody OrganizationsCreateJSONBody

// ModelsCreateForOrganizationJSONRequestBody defines body for ModelsCreateForOrganization for application/json ContentType.
type ModelsCreateForOrganizationJSONRequestBody ModelsCreateForOrganizationJSONBody

// VersionsCreateForModelJSONRequestBody defines body for VersionsCreateForModel for application/json ContentType.
type VersionsCreateForModelJSONRequestBody VersionsCreateForModelJSONBody

// ResultsCreateForVersionJSONRequestBody defines body for ResultsCreateForVersion for application/json ContentType.
type ResultsCreateForVersionJSONRequestBody ResultsCreateForVersionJSONBody

// SchemasCreateForOrganizationJSONRequestBody defines body for SchemasCreateForOrganization for application/json ContentType.
type SchemasCreateForOrganizationJSONRequestBody SchemasCreateForOrganizationJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// OrganizationsCreate request with any body
	OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsListForOrganization request
	ModelsListForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsCreateForOrganization request with any body
	ModelsCreateForOrganizationWithBody(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModelsCreateForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, body ModelsCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelsGetForOrganization request
	ModelsGetForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsListForModel request
	VersionsListForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsCreateForModel request with any body
	VersionsCreateForModelWithBody(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VersionsCreateForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, body VersionsCreateForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsGetForModel request
	VersionsGetForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultsListForVersion request
	ResultsListForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultsCreateForVersion request with any body
	ResultsCreateForVersionWithBody(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResultsCreateForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, body ResultsCreateForVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultsGetForVersion request
	ResultsGetForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasListForOrganization request
	SchemasListForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasCreateForOrganization request with any body
	SchemasCreateForOrganizationWithBody(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchemasCreateForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, body SchemasCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasGetForOrganization request
	SchemasGetForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsListForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsListForOrganizationRequest(c.Server, parameterOrganization)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreateForOrganizationWithBody(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateForOrganizationRequestWithBody(c.Server, parameterOrganization, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsCreateForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, body ModelsCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsCreateForOrganizationRequest(c.Server, parameterOrganization, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelsGetForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelsGetForOrganizationRequest(c.Server, parameterOrganization, parameterModel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsListForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsListForModelRequest(c.Server, parameterOrganization, parameterModel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsCreateForModelWithBody(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsCreateForModelRequestWithBody(c.Server, parameterOrganization, parameterModel, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsCreateForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, body VersionsCreateForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsCreateForModelRequest(c.Server, parameterOrganization, parameterModel, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsGetForModel(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsGetForModelRequest(c.Server, parameterOrganization, parameterModel, parameterVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultsListForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultsListForVersionRequest(c.Server, parameterOrganization, parameterModel, parameterVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultsCreateForVersionWithBody(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultsCreateForVersionRequestWithBody(c.Server, parameterOrganization, parameterModel, parameterVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultsCreateForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, body ResultsCreateForVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultsCreateForVersionRequest(c.Server, parameterOrganization, parameterModel, parameterVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultsGetForVersion(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultsGetForVersionRequest(c.Server, parameterOrganization, parameterModel, parameterVersion, parameterResult)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasListForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasListForOrganizationRequest(c.Server, parameterOrganization)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasCreateForOrganizationWithBody(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasCreateForOrganizationRequestWithBody(c.Server, parameterOrganization, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasCreateForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, body SchemasCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasCreateForOrganizationRequest(c.Server, parameterOrganization, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasGetForOrganization(ctx context.Context, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasGetForOrganizationRequest(c.Server, parameterOrganization, parameterSchema)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewOrganizationsCreateRequest calls the generic OrganizationsCreate builder with application/json body
func NewOrganizationsCreateRequest(server string, body OrganizationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrganizationsCreateRequestWithBody generates requests for OrganizationsCreate with any type of body
func NewOrganizationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelsListForOrganizationRequest generates requests for ModelsListForOrganization
func NewModelsListForOrganizationRequest(server string, parameterOrganization ParameterOrganization) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelsCreateForOrganizationRequest calls the generic ModelsCreateForOrganization builder with application/json body
func NewModelsCreateForOrganizationRequest(server string, parameterOrganization ParameterOrganization, body ModelsCreateForOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModelsCreateForOrganizationRequestWithBody(server, parameterOrganization, "application/json", bodyReader)
}

// NewModelsCreateForOrganizationRequestWithBody generates requests for ModelsCreateForOrganization with any type of body
func NewModelsCreateForOrganizationRequestWithBody(server string, parameterOrganization ParameterOrganization, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModelsGetForOrganizationRequest generates requests for ModelsGetForOrganization
func NewModelsGetForOrganizationRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionsListForModelRequest generates requests for VersionsListForModel
func NewVersionsListForModelRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionsCreateForModelRequest calls the generic VersionsCreateForModel builder with application/json body
func NewVersionsCreateForModelRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, body VersionsCreateForModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVersionsCreateForModelRequestWithBody(server, parameterOrganization, parameterModel, "application/json", bodyReader)
}

// NewVersionsCreateForModelRequestWithBody generates requests for VersionsCreateForModel with any type of body
func NewVersionsCreateForModelRequestWithBody(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVersionsGetForModelRequest generates requests for VersionsGetForModel
func NewVersionsGetForModelRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, parameterVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResultsListForVersionRequest generates requests for ResultsListForVersion
func NewResultsListForVersionRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, parameterVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions/%s/results", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResultsCreateForVersionRequest calls the generic ResultsCreateForVersion builder with application/json body
func NewResultsCreateForVersionRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, body ResultsCreateForVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResultsCreateForVersionRequestWithBody(server, parameterOrganization, parameterModel, parameterVersion, "application/json", bodyReader)
}

// NewResultsCreateForVersionRequestWithBody generates requests for ResultsCreateForVersion with any type of body
func NewResultsCreateForVersionRequestWithBody(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, parameterVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions/%s/results", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResultsGetForVersionRequest generates requests for ResultsGetForVersion
func NewResultsGetForVersionRequest(server string, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, parameterModel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, parameterVersion)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "result", runtime.ParamLocationPath, parameterResult)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/models/%s/versions/%s/results/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasListForOrganizationRequest generates requests for SchemasListForOrganization
func NewSchemasListForOrganizationRequest(server string, parameterOrganization ParameterOrganization) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasCreateForOrganizationRequest calls the generic SchemasCreateForOrganization builder with application/json body
func NewSchemasCreateForOrganizationRequest(server string, parameterOrganization ParameterOrganization, body SchemasCreateForOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchemasCreateForOrganizationRequestWithBody(server, parameterOrganization, "application/json", bodyReader)
}

// NewSchemasCreateForOrganizationRequestWithBody generates requests for SchemasCreateForOrganization with any type of body
func NewSchemasCreateForOrganizationRequestWithBody(server string, parameterOrganization ParameterOrganization, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemasGetForOrganizationRequest generates requests for SchemasGetForOrganization
func NewSchemasGetForOrganizationRequest(server string, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization", runtime.ParamLocationPath, parameterOrganization)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schema", runtime.ParamLocationPath, parameterSchema)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/schemas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// OrganizationsCreate request with any body
	OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	// ModelsListForOrganization request
	ModelsListForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*ModelsListForOrganizationResponse, error)

	// ModelsCreateForOrganization request with any body
	ModelsCreateForOrganizationWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateForOrganizationResponse, error)

	ModelsCreateForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, body ModelsCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateForOrganizationResponse, error)

	// ModelsGetForOrganization request
	ModelsGetForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*ModelsGetForOrganizationResponse, error)

	// VersionsListForModel request
	VersionsListForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*VersionsListForModelResponse, error)

	// VersionsCreateForModel request with any body
	VersionsCreateForModelWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsCreateForModelResponse, error)

	VersionsCreateForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, body VersionsCreateForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsCreateForModelResponse, error)

	// VersionsGetForModel request
	VersionsGetForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*VersionsGetForModelResponse, error)

	// ResultsListForVersion request
	ResultsListForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*ResultsListForVersionResponse, error)

	// ResultsCreateForVersion request with any body
	ResultsCreateForVersionWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResultsCreateForVersionResponse, error)

	ResultsCreateForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, body ResultsCreateForVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResultsCreateForVersionResponse, error)

	// ResultsGetForVersion request
	ResultsGetForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult, reqEditors ...RequestEditorFn) (*ResultsGetForVersionResponse, error)

	// SchemasListForOrganization request
	SchemasListForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*SchemasListForOrganizationResponse, error)

	// SchemasCreateForOrganization request with any body
	SchemasCreateForOrganizationWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasCreateForOrganizationResponse, error)

	SchemasCreateForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, body SchemasCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasCreateForOrganizationResponse, error)

	// SchemasGetForOrganization request
	SchemasGetForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema, reqEditors ...RequestEditorFn) (*SchemasGetForOrganizationResponse, error)
}

type OrganizationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Organization
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r OrganizationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsListForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Model
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ModelsListForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsListForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsCreateForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Model
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ModelsCreateForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsCreateForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelsGetForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ModelsGetForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelsGetForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsListForModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Version
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r VersionsListForModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsListForModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsCreateForModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Version
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r VersionsCreateForModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsCreateForModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsGetForModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r VersionsGetForModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsGetForModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultsListForVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Result
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ResultsListForVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultsListForVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultsCreateForVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Result
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ResultsCreateForVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultsCreateForVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultsGetForVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Result
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ResultsGetForVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultsGetForVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasListForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Schema
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SchemasListForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasListForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasCreateForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Schema
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SchemasCreateForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasCreateForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasGetForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schema
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SchemasGetForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasGetForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// OrganizationsCreateWithBodyWithResponse request with arbitrary body returning *OrganizationsCreateResponse
func (c *ClientWithResponses) OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

// ModelsListForOrganizationWithResponse request returning *ModelsListForOrganizationResponse
func (c *ClientWithResponses) ModelsListForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*ModelsListForOrganizationResponse, error) {
	rsp, err := c.ModelsListForOrganization(ctx, parameterOrganization, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsListForOrganizationResponse(rsp)
}

// ModelsCreateForOrganizationWithBodyWithResponse request with arbitrary body returning *ModelsCreateForOrganizationResponse
func (c *ClientWithResponses) ModelsCreateForOrganizationWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModelsCreateForOrganizationResponse, error) {
	rsp, err := c.ModelsCreateForOrganizationWithBody(ctx, parameterOrganization, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateForOrganizationResponse(rsp)
}

func (c *ClientWithResponses) ModelsCreateForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, body ModelsCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModelsCreateForOrganizationResponse, error) {
	rsp, err := c.ModelsCreateForOrganization(ctx, parameterOrganization, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsCreateForOrganizationResponse(rsp)
}

// ModelsGetForOrganizationWithResponse request returning *ModelsGetForOrganizationResponse
func (c *ClientWithResponses) ModelsGetForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*ModelsGetForOrganizationResponse, error) {
	rsp, err := c.ModelsGetForOrganization(ctx, parameterOrganization, parameterModel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelsGetForOrganizationResponse(rsp)
}

// VersionsListForModelWithResponse request returning *VersionsListForModelResponse
func (c *ClientWithResponses) VersionsListForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, reqEditors ...RequestEditorFn) (*VersionsListForModelResponse, error) {
	rsp, err := c.VersionsListForModel(ctx, parameterOrganization, parameterModel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsListForModelResponse(rsp)
}

// VersionsCreateForModelWithBodyWithResponse request with arbitrary body returning *VersionsCreateForModelResponse
func (c *ClientWithResponses) VersionsCreateForModelWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsCreateForModelResponse, error) {
	rsp, err := c.VersionsCreateForModelWithBody(ctx, parameterOrganization, parameterModel, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsCreateForModelResponse(rsp)
}

func (c *ClientWithResponses) VersionsCreateForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, body VersionsCreateForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsCreateForModelResponse, error) {
	rsp, err := c.VersionsCreateForModel(ctx, parameterOrganization, parameterModel, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsCreateForModelResponse(rsp)
}

// VersionsGetForModelWithResponse request returning *VersionsGetForModelResponse
func (c *ClientWithResponses) VersionsGetForModelWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*VersionsGetForModelResponse, error) {
	rsp, err := c.VersionsGetForModel(ctx, parameterOrganization, parameterModel, parameterVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsGetForModelResponse(rsp)
}

// ResultsListForVersionWithResponse request returning *ResultsListForVersionResponse
func (c *ClientWithResponses) ResultsListForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, reqEditors ...RequestEditorFn) (*ResultsListForVersionResponse, error) {
	rsp, err := c.ResultsListForVersion(ctx, parameterOrganization, parameterModel, parameterVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultsListForVersionResponse(rsp)
}

// ResultsCreateForVersionWithBodyWithResponse request with arbitrary body returning *ResultsCreateForVersionResponse
func (c *ClientWithResponses) ResultsCreateForVersionWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResultsCreateForVersionResponse, error) {
	rsp, err := c.ResultsCreateForVersionWithBody(ctx, parameterOrganization, parameterModel, parameterVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultsCreateForVersionResponse(rsp)
}

func (c *ClientWithResponses) ResultsCreateForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, body ResultsCreateForVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResultsCreateForVersionResponse, error) {
	rsp, err := c.ResultsCreateForVersion(ctx, parameterOrganization, parameterModel, parameterVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultsCreateForVersionResponse(rsp)
}

// ResultsGetForVersionWithResponse request returning *ResultsGetForVersionResponse
func (c *ClientWithResponses) ResultsGetForVersionWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult, reqEditors ...RequestEditorFn) (*ResultsGetForVersionResponse, error) {
	rsp, err := c.ResultsGetForVersion(ctx, parameterOrganization, parameterModel, parameterVersion, parameterResult, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultsGetForVersionResponse(rsp)
}

// SchemasListForOrganizationWithResponse request returning *SchemasListForOrganizationResponse
func (c *ClientWithResponses) SchemasListForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, reqEditors ...RequestEditorFn) (*SchemasListForOrganizationResponse, error) {
	rsp, err := c.SchemasListForOrganization(ctx, parameterOrganization, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasListForOrganizationResponse(rsp)
}

// SchemasCreateForOrganizationWithBodyWithResponse request with arbitrary body returning *SchemasCreateForOrganizationResponse
func (c *ClientWithResponses) SchemasCreateForOrganizationWithBodyWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasCreateForOrganizationResponse, error) {
	rsp, err := c.SchemasCreateForOrganizationWithBody(ctx, parameterOrganization, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasCreateForOrganizationResponse(rsp)
}

func (c *ClientWithResponses) SchemasCreateForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, body SchemasCreateForOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasCreateForOrganizationResponse, error) {
	rsp, err := c.SchemasCreateForOrganization(ctx, parameterOrganization, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasCreateForOrganizationResponse(rsp)
}

// SchemasGetForOrganizationWithResponse request returning *SchemasGetForOrganizationResponse
func (c *ClientWithResponses) SchemasGetForOrganizationWithResponse(ctx context.Context, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema, reqEditors ...RequestEditorFn) (*SchemasGetForOrganizationResponse, error) {
	rsp, err := c.SchemasGetForOrganization(ctx, parameterOrganization, parameterSchema, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasGetForOrganizationResponse(rsp)
}

// ParseOrganizationsCreateResponse parses an HTTP response from a OrganizationsCreateWithResponse call
func ParseOrganizationsCreateResponse(rsp *http.Response) (*OrganizationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseModelsListForOrganizationResponse parses an HTTP response from a ModelsListForOrganizationWithResponse call
func ParseModelsListForOrganizationResponse(rsp *http.Response) (*ModelsListForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsListForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseModelsCreateForOrganizationResponse parses an HTTP response from a ModelsCreateForOrganizationWithResponse call
func ParseModelsCreateForOrganizationResponse(rsp *http.Response) (*ModelsCreateForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsCreateForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseModelsGetForOrganizationResponse parses an HTTP response from a ModelsGetForOrganizationWithResponse call
func ParseModelsGetForOrganizationResponse(rsp *http.Response) (*ModelsGetForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelsGetForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVersionsListForModelResponse parses an HTTP response from a VersionsListForModelWithResponse call
func ParseVersionsListForModelResponse(rsp *http.Response) (*VersionsListForModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsListForModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVersionsCreateForModelResponse parses an HTTP response from a VersionsCreateForModelWithResponse call
func ParseVersionsCreateForModelResponse(rsp *http.Response) (*VersionsCreateForModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsCreateForModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVersionsGetForModelResponse parses an HTTP response from a VersionsGetForModelWithResponse call
func ParseVersionsGetForModelResponse(rsp *http.Response) (*VersionsGetForModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsGetForModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResultsListForVersionResponse parses an HTTP response from a ResultsListForVersionWithResponse call
func ParseResultsListForVersionResponse(rsp *http.Response) (*ResultsListForVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultsListForVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Result
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResultsCreateForVersionResponse parses an HTTP response from a ResultsCreateForVersionWithResponse call
func ParseResultsCreateForVersionResponse(rsp *http.Response) (*ResultsCreateForVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultsCreateForVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Result
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResultsGetForVersionResponse parses an HTTP response from a ResultsGetForVersionWithResponse call
func ParseResultsGetForVersionResponse(rsp *http.Response) (*ResultsGetForVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultsGetForVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Result
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSchemasListForOrganizationResponse parses an HTTP response from a SchemasListForOrganizationWithResponse call
func ParseSchemasListForOrganizationResponse(rsp *http.Response) (*SchemasListForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasListForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSchemasCreateForOrganizationResponse parses an HTTP response from a SchemasCreateForOrganizationWithResponse call
func ParseSchemasCreateForOrganizationResponse(rsp *http.Response) (*SchemasCreateForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasCreateForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSchemasGetForOrganizationResponse parses an HTTP response from a SchemasGetForOrganizationWithResponse call
func ParseSchemasGetForOrganizationResponse(rsp *http.Response) (*SchemasGetForOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasGetForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create an organization
	// (POST /organizations)
	OrganizationsCreate(w http.ResponseWriter, r *http.Request)
	// List organization models
	// (GET /organizations/{organization}/models)
	ModelsListForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization)
	// Create an organization model
	// (POST /organizations/{organization}/models)
	ModelsCreateForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization)
	// Get organization model
	// (GET /organizations/{organization}/models/{model})
	ModelsGetForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel)
	// List model versions
	// (GET /organizations/{organization}/models/{model}/versions)
	VersionsListForModel(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel)
	// Create a model version
	// (POST /organizations/{organization}/models/{model}/versions)
	VersionsCreateForModel(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel)
	// Get model version
	// (GET /organizations/{organization}/models/{model}/versions/{version})
	VersionsGetForModel(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion)
	// List results
	// (GET /organizations/{organization}/models/{model}/versions/{version}/results)
	ResultsListForVersion(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion)
	// Create a model result
	// (POST /organizations/{organization}/models/{model}/versions/{version}/results)
	ResultsCreateForVersion(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion)
	// Get a result
	// (GET /organizations/{organization}/models/{model}/versions/{version}/results/{result})
	ResultsGetForVersion(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterModel ParameterModel, parameterVersion ParameterVersion, parameterResult ParameterResult)
	// List organization schemas
	// (GET /organizations/{organization}/schemas)
	SchemasListForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization)
	// Create an organization schema
	// (POST /organizations/{organization}/schemas)
	SchemasCreateForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization)
	// Get organization schema
	// (GET /organizations/{organization}/schemas/{schema})
	SchemasGetForOrganization(w http.ResponseWriter, r *http.Request, parameterOrganization ParameterOrganization, parameterSchema ParameterSchema)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// OrganizationsCreate operation middleware
func (siw *ServerInterfaceWrapper) OrganizationsCreate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OrganizationsCreate(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ModelsListForOrganization operation middleware
func (siw *ServerInterfaceWrapper) ModelsListForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModelsListForOrganization(w, r, parameterOrganization)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ModelsCreateForOrganization operation middleware
func (siw *ServerInterfaceWrapper) ModelsCreateForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModelsCreateForOrganization(w, r, parameterOrganization)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ModelsGetForOrganization operation middleware
func (siw *ServerInterfaceWrapper) ModelsGetForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ModelsGetForOrganization(w, r, parameterOrganization, parameterModel)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// VersionsListForModel operation middleware
func (siw *ServerInterfaceWrapper) VersionsListForModel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VersionsListForModel(w, r, parameterOrganization, parameterModel)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// VersionsCreateForModel operation middleware
func (siw *ServerInterfaceWrapper) VersionsCreateForModel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VersionsCreateForModel(w, r, parameterOrganization, parameterModel)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// VersionsGetForModel operation middleware
func (siw *ServerInterfaceWrapper) VersionsGetForModel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var parameterVersion ParameterVersion

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, chi.URLParam(r, "version"), &parameterVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VersionsGetForModel(w, r, parameterOrganization, parameterModel, parameterVersion)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ResultsListForVersion operation middleware
func (siw *ServerInterfaceWrapper) ResultsListForVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var parameterVersion ParameterVersion

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, chi.URLParam(r, "version"), &parameterVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResultsListForVersion(w, r, parameterOrganization, parameterModel, parameterVersion)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ResultsCreateForVersion operation middleware
func (siw *ServerInterfaceWrapper) ResultsCreateForVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var parameterVersion ParameterVersion

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, chi.URLParam(r, "version"), &parameterVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResultsCreateForVersion(w, r, parameterOrganization, parameterModel, parameterVersion)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ResultsGetForVersion operation middleware
func (siw *ServerInterfaceWrapper) ResultsGetForVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "model" -------------
	var parameterModel ParameterModel

	err = runtime.BindStyledParameterWithLocation("simple", false, "model", runtime.ParamLocationPath, chi.URLParam(r, "model"), &parameterModel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "model", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var parameterVersion ParameterVersion

	err = runtime.BindStyledParameterWithLocation("simple", false, "version", runtime.ParamLocationPath, chi.URLParam(r, "version"), &parameterVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	// ------------- Path parameter "result" -------------
	var parameterResult ParameterResult

	err = runtime.BindStyledParameterWithLocation("simple", false, "result", runtime.ParamLocationPath, chi.URLParam(r, "result"), &parameterResult)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "result", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResultsGetForVersion(w, r, parameterOrganization, parameterModel, parameterVersion, parameterResult)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SchemasListForOrganization operation middleware
func (siw *ServerInterfaceWrapper) SchemasListForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SchemasListForOrganization(w, r, parameterOrganization)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SchemasCreateForOrganization operation middleware
func (siw *ServerInterfaceWrapper) SchemasCreateForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SchemasCreateForOrganization(w, r, parameterOrganization)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SchemasGetForOrganization operation middleware
func (siw *ServerInterfaceWrapper) SchemasGetForOrganization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "organization" -------------
	var parameterOrganization ParameterOrganization

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization", runtime.ParamLocationPath, chi.URLParam(r, "organization"), &parameterOrganization)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "organization", Err: err})
		return
	}

	// ------------- Path parameter "schema" -------------
	var parameterSchema ParameterSchema

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema", runtime.ParamLocationPath, chi.URLParam(r, "schema"), &parameterSchema)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schema", Err: err})
		return
	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SchemasGetForOrganization(w, r, parameterOrganization, parameterSchema)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/organizations", wrapper.OrganizationsCreate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models", wrapper.ModelsListForOrganization)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/organizations/{organization}/models", wrapper.ModelsCreateForOrganization)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models/{model}", wrapper.ModelsGetForOrganization)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models/{model}/versions", wrapper.VersionsListForModel)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/organizations/{organization}/models/{model}/versions", wrapper.VersionsCreateForModel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models/{model}/versions/{version}", wrapper.VersionsGetForModel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models/{model}/versions/{version}/results", wrapper.ResultsListForVersion)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/organizations/{organization}/models/{model}/versions/{version}/results", wrapper.ResultsCreateForVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/models/{model}/versions/{version}/results/{result}", wrapper.ResultsGetForVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/schemas", wrapper.SchemasListForOrganization)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/organizations/{organization}/schemas", wrapper.SchemasCreateForOrganization)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/organizations/{organization}/schemas/{schema}", wrapper.SchemasGetForOrganization)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xc3W/bOBL/VwjeAfsiW3KSHnb1ltt2ezlcm0UT7MPFfmCksc2tLOpIKm3O0P++4Jdk",
	"fdly4iROEWCBtSR+DIe/Gf5mOOkaR2yVsRRSKXC4xhnhZAUSuH76xGJI1I8YRMRpJilLcYivl4BW6hNK",
	"yQrGSD2rX4gKlDKJIiIACUgFlfQOxtjDVHXLiFxiD6uWOMR6AOxhDv/LKYcYh5Ln4GERLWFF1KTyPlMN",
	"heQ0XeDCw99HCzay3X93ghoZCw9f8gVJ6f+JEbJLZrbR4jGib45zgBXUBC88/AVEnsjuJXD9DV287xHN",
	"fB8iFE0lLID3SmWlKDx8VXZty2OGfYwyrWCPV6MVs/DwH8BFLwjuzMfHiGyHOIDMTtKiUGOJjKUCtOV9",
	"4JypLdBv1IuIpRJSjQqSZQmNNFz8P4VZZzXx3znMcYj/5leG7Zuvwtej4kLNVlfMeYpAfUNOiLEWyfYr",
	"BWprtKOjhzPOMuCSmqVELNYrgO9klSWAw7PgzOtAIbgZyob4M5PoN5anMfaaCi02lX9jJnFjzAqvz3Wd",
	"W8fFIeMglHIQQSsSLWkKKAHCU5oukAB+RyNA8zxJ5jRJ1Ds1GwgpOhbIgUglxqboJ8FkMgrORpPg+iQI",
	"g1/C08l/sYfnjK+IxCGOiYSRpCtoL83DtD7Y5OT07N0/WjqrY+riveppHpqr/qwQzuZIOsetFlHJym7/",
	"hEiOYpAQSca7JGJbnevF+9roP4maq61N1rOWwsN5Fneq8WwUnI6C0+vJz+G7n8NJMFSNDYTQ2Bmw13Tg",
	"bgMrGWYellRqCT7Zc8qObnS1+7w5T+vHDVVAU9OLjESAliyJFaq0vgQiaazUR7l1qK8eZb37rxxZet8l",
	"zjPu/9YNv6yDo7XvfcfzuTucN3yLVkUus1yijLM4jwDd3iOCMsIljfKE8PI8YvMfyxPRNMt7SIz+hBb0",
	"DlIkWeU31INTk1xSYRVax484DX3/No++gvTVsexL5tvN6ZB/1X0MNBzWQA/1DE7QgKWHvhogySUp0RQr",
	"OFX6mzOun4xqtZrryrtZT3GUECGmOERTHBE5xR6aYhExDupdMP6l8FC91VcqJaSthu+K2TTt0rnGUucK",
	"1BchySpTmvq2VNtfcdpvRJTLGqP3MCd5okzIAER1NUsvlzuSnERfnZWA4iAR0DsQdlRtJfX1P8oWFMW7",
	"3LI/EeMcIlnbJ7FkeRKjW6h2bN9N6lT/pE/5h/aiXsl2twDeNhmE8eHHsosQK7ptfEppJbUtsbjb4dy/",
	"uPio5db7opxzF+M03Dp8zyCSECMheR7JnJdnn5bSnOlGULHdub9aP/7vq8vPyOgNbXxtukGjjxo4+uIj",
	"+1ZFNeMv5NsnEIIs4JUT220+faAKzRDdKmwG8v06fEaG1bLUfSj3lUsJtIy0N7I/L3lULbL7UcnVQWnN",
	"KzYt0eO0q8Gt8+50SZsu+uiDVHcalvmyrSb0R3lmNmyo0C59znrSeRlEdG6TS5qp/KrCtZ+EI+iOcZ3/",
	"fqE0ltAIbILK4vM8I9ES0Mk4MFTQiFPnaxtneogn42AcjEiSLclEoyaDlGQUh/hUfVFmSORSW6C/qRKT",
	"rmaiw7H+qjWjtreFKWXQ+uEiboR6wvSyST0Q8p8svh+QebMwEEYMTVrVzzuS5Jt6MWFvUdRAW3cw3XZY",
	"Zih7IuvtgNJjzjpRUM9dNhOQJ8HkYGnHeoK7nX0s85yFh8/MvF3DlfL59eyo7nX6kF4nJw/o9S4I9u6l",
	"dj1frQi/L+HZRKfaSrIQatPqMJ+p3nXo++vNx8I3WSQl1QI67OE/VFjSatNNNN1tGzrvJVTX3xhv5EQ2",
	"b4luulVRNWls/6wFtGAvoFEJK7ELceWlkMU94ZzcHxX0grOXgJ7aznpe0kKnAp99MSu8Xd7VngnDwWR6",
	"PgGcnsJfqwCczinwQzjtkkC9Am9tbefNTXe6aeR4WMteBnppf63/X/R6648gH2JcH+HAjtrb2d4i5bEe",
	"/XWB8WUc90eQTwND3zLxIezBNdWBAamcWh2ONvRw1MHdn70KKA4iF+Wl/Ru96KIXxnGVsKogWr4awi1c",
	"5mYQ1Epi8fxgewLqcadC4kkV6tt0xAFoyEaevpWtEVuqfFrplFy4qycqNpNsXVynL/Nv0xx23pdmPVUl",
	"zhvvMbynbsjddvzQw8Zf2187adBefsBwoGd1Arsblsh6Sp50jPB9Oab0LMj1zb31EOJkW1oQ9xZ/dIPb",
	"XFk6OlUldn80eA/iXlVV6hv1alMvh8gK8e7NEMpVVdt0ArAkWUcOwUMyMnv5jW+mOCMLQBNlqSfTqS3H",
	"0O9OOt7pdhP9ztRpuDtgvJ7ijENMI+10pjhENxMPqf9mRWFKOnT5TN+l0mYRSs9gQTmYhshp54q2llGV",
	"0j5JvdDw9Q2vhNlKjg9bita+59xds7VXudbxF1QdQ73UjovULZVCLx1quDPsLdKoRxrl3660D6/DsTV/",
	"bX7sDDysET2Gsplw5HiPy91NHVSfMnQ5QnN4uciFPMoKNv5eZ0dEYlsOul8w5Viv9Sq4+rOwt4hhx12w",
	"g0+FPfdmSPhgU4N7IOpV3AeX5LHFb9o3xZtcsJX9fCBD3bvI9kGFtM1MsRF0b7q7Vznrbmm7M8YNbvfS",
	"dM45mDc6131hXhYstp3K0APNX5sfO0nb/j7oBa7NHWCeklQdISiP5OJ8GxxVTx35mn3PeYJDvM44kyxi",
	"SRH6/nrJhFR+qPBJRv27iS1c9fAd4ZTc2oPEtaodKvhfl1fXn88/fcDNPbmCZD5SfSDuicTdgGOlFCdQ",
	"ffSllNkDRnaDjRVYZqVamgb2IY0zRlOTP1iRlCzqpagC5UKNqtz8lw9X165CuOOfTBDaSHYP31usuH0q",
	"WwkxbI5+Hrx9EgeaYbOUhRNV0Lh9+PKiYtj47n5BD98OULfP5eKLYlb8FQAA//8Q60gRDkQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
